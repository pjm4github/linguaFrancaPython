#!/usr/bin/env python
""" generated source for module LFSemanticSequencer """
# 
#  * generated by Xtext 2.28.0
#  
# package: org.lflang.serializer
import com.google.inject.Inject
# import java.util.Set
# import org.eclipse.emf.ecore.EObject
# import org.eclipse.emf.ecore.EPackage
# import org.eclipse.xtext.Action
# import org.eclipse.xtext.Parameter
# import org.eclipse.xtext.ParserRule
# import org.eclipse.xtext.serializer.ISerializationContext
# import org.eclipse.xtext.serializer.acceptor.SequenceFeeder
# import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer
# import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient

from org.lflang.lf import Array

from org.lflang.lf import ArraySpec

from org.lflang.lf import Assignment

from org.lflang.lf import AttrParm

from org.lflang.lf import AttrParmValue

from org.lflang.lf import Attribute

from org.lflang.lf import BuiltinTriggerRef

from org.lflang.lf import LFCode

from org.lflang.lf import Connection

from org.lflang.lf import Deadline

from org.lflang.lf import Element

from org.lflang.lf.IPV4Host

from org.lflang.lf.IPV6Host

from org.lflang.lf.Import

from org.lflang.lf.ImportedReactor

from org.lflang.lf.Input

from org.lflang.lf.Instantiation

from org.lflang.lf.KeyValuePair

from org.lflang.lf.KeyValuePairs

from org.lflang.lf.LfPackage

from org.lflang.lf.Literal

from org.lflang.lf.Method

from org.lflang.lf.MethodArgument

from org.lflang.lf.Mode

from org.lflang.lf.Model

from org.lflang.lf.NamedHost

from org.lflang.lf.Output

from org.lflang.lf.ParameterReference

from org.lflang.lf.Preamble

from org.lflang.lf.Reaction

from org.lflang.lf.Reactor

from org.lflang.lf.STP

from org.lflang.lf.Serializer

from org.lflang.lf.StateVar

from org.lflang.lf.TargetDecl

from org.lflang.lf.Time

from org.lflang.lf.Timer

from org.lflang.lf.Type

from org.lflang.lf.TypeParm

from org.lflang.lf.VarRef

from org.lflang.lf.WidthSpec

from org.lflang.lf.WidthTerm

from org.lflang.services.LFGrammarAccess

@SuppressWarnings("all")
class LFSemanticSequencer(AbstractDelegatingSemanticSequencer):
    """ generated source for class LFSemanticSequencer """
    grammarAccess = None

    def sequence(self, context, semanticObject):
        """ generated source for method sequence """
        epackage = semanticObject.eClass().getEPackage()
        rule = context.getParserRule()
        action = context.getAssignedAction()
        parameters = context.getEnabledBooleanParameters()
        if epackage == LfPackage.eINSTANCE:
            if semanticObject.eClass().getClassifierID() == LfPackage.ACTION:
                sequence_Action(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.ARRAY:
                sequence_Array(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.ARRAY_SPEC:
                sequence_ArraySpec(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.ASSIGNMENT:
                sequence_Assignment(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.ATTR_PARM:
                sequence_AttrParm(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.ATTR_PARM_VALUE:
                sequence_AttrParmValue(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.ATTRIBUTE:
                sequence_Attribute(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.BUILTIN_TRIGGER_REF:
                sequence_BuiltinTriggerRef(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.CODE:
                sequence_Code(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.CONNECTION:
                sequence_Connection(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.DEADLINE:
                sequence_Deadline(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.ELEMENT:
                sequence_Element(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.IPV4_HOST:
                sequence_IPV4Host(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.IPV6_HOST:
                sequence_IPV6Host(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.IMPORT:
                sequence_Import(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.IMPORTED_REACTOR:
                sequence_ImportedReactor(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.INPUT:
                sequence_Input(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.INSTANTIATION:
                sequence_Instantiation(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.KEY_VALUE_PAIR:
                sequence_KeyValuePair(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.KEY_VALUE_PAIRS:
                sequence_KeyValuePairs(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.LITERAL:
                sequence_Expression(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.METHOD:
                sequence_Method(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.METHOD_ARGUMENT:
                sequence_MethodArgument(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.MODE:
                sequence_Mode(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.MODEL:
                sequence_Model(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.NAMED_HOST:
                sequence_NamedHost(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.OUTPUT:
                sequence_Output(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.PARAMETER:
                sequence_Parameter(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.PARAMETER_REFERENCE:
                sequence_ParameterReference(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.PREAMBLE:
                sequence_Preamble(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.REACTION:
                sequence_Reaction(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.REACTOR:
                sequence_Reactor(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.STP:
                sequence_STP(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.SERIALIZER:
                sequence_Serializer(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.STATE_VAR:
                sequence_StateVar(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.TARGET_DECL:
                sequence_TargetDecl(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.TIME:
                sequence_Time(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.TIMER:
                sequence_Timer(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.TYPE:
                sequence_Type(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.TYPE_PARM:
                sequence_TypeParm(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.VAR_REF:
                if rule == self.grammarAccess.getTriggerRefRule() or rule == self.grammarAccess.getVarRefRule():
                    sequence_VarRef(context, semanticObject)
                    return
                elif rule == self.grammarAccess.getVarRefOrModeTransitionRule():
                    sequence_VarRef_VarRefOrModeTransition(context, semanticObject)
                    return
                else:
                    pass
            elif semanticObject.eClass().getClassifierID() == LfPackage.WIDTH_SPEC:
                sequence_WidthSpec(context, semanticObject)
                return
            elif semanticObject.eClass().getClassifierID() == LfPackage.WIDTH_TERM:
                sequence_WidthTerm(context, semanticObject)
                return
        if errorAcceptor != None:
            errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context))

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Action returns Action
    # 	 *     TypedVariable returns Action
    # 	 *     Variable returns Action
    # 	 *
    # 	 * Constraint:
    # 	 *     (attributes+=Attribute* origin=ActionOrigin? name=ID (minDelay=Expression (minSpacing=Expression policy=STRING?)?)? type=Type?)
    # 	 * </pre>
    # 	 
    def sequence_Action(self, context, semanticObject):
        """ generated source for method sequence_Action """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     ArraySpec returns ArraySpec
    # 	 *
    # 	 * Constraint:
    # 	 *     (ofVariableLength?=']' | length=INT)
    # 	 * </pre>
    # 	 
    def sequence_ArraySpec(self, context, semanticObject):
        """ generated source for method sequence_ArraySpec """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Array returns Array
    # 	 *
    # 	 * Constraint:
    # 	 *     (elements+=Element elements+=Element*)
    # 	 * </pre>
    # 	 
    def sequence_Array(self, context, semanticObject):
        """ generated source for method sequence_Array """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Assignment returns Assignment
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         lhs=[Parameter|ID] 
    # 	 *         (
    # 	 *             (equals='=' rhs+=Expression) | 
    # 	 *             (equals='='? ((parens+='(' (rhs+=Expression rhs+=Expression*)? parens+=')') | (braces+='{' (rhs+=Expression rhs+=Expression*)? braces+='}')))
    # 	 *         )
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_Assignment(self, context, semanticObject):
        """ generated source for method sequence_Assignment """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     AttrParmValue returns AttrParmValue
    # 	 *
    # 	 * Constraint:
    # 	 *     (str=STRING | int=SignedInt | bool=Boolean | float=SignedFloat)
    # 	 * </pre>
    # 	 
    def sequence_AttrParmValue(self, context, semanticObject):
        """ generated source for method sequence_AttrParmValue """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     AttrParm returns AttrParm
    # 	 *
    # 	 * Constraint:
    # 	 *     (name=ID? value=AttrParmValue)
    # 	 * </pre>
    # 	 
    def sequence_AttrParm(self, context, semanticObject):
        """ generated source for method sequence_AttrParm """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Attribute returns Attribute
    # 	 *
    # 	 * Constraint:
    # 	 *     (attrName=ID (attrParms+=AttrParm attrParms+=AttrParm*)?)
    # 	 * </pre>
    # 	 
    def sequence_Attribute(self, context, semanticObject):
        """ generated source for method sequence_Attribute """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     TriggerRef returns BuiltinTriggerRef
    # 	 *     BuiltinTriggerRef returns BuiltinTriggerRef
    # 	 *
    # 	 * Constraint:
    # 	 *     type=BuiltinTrigger
    # 	 * </pre>
    # 	 
    def sequence_BuiltinTriggerRef(self, context, semanticObject):
        """ generated source for method sequence_BuiltinTriggerRef """
        if errorAcceptor != None:
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.BUILTIN_TRIGGER_REF__TYPE) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.BUILTIN_TRIGGER_REF__TYPE))
        feeder = createSequencerFeeder(context, semanticObject)
        feeder.accept(self.grammarAccess.getBuiltinTriggerRefAccess().getTypeBuiltinTriggerEnumRuleCall_0(), semanticObject.getType())
        feeder.finish()

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Expression returns Code
    # 	 *     Code returns Code
    # 	 *
    # 	 * Constraint:
    # 	 *     body=Body
    # 	 * </pre>
    # 	 
    def sequence_Code(self, context, semanticObject):
        """ generated source for method sequence_Code """
        if errorAcceptor != None:
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.CODE__BODY) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.CODE__BODY))
        feeder = createSequencerFeeder(context, semanticObject)
        feeder.accept(self.grammarAccess.getCodeAccess().getBodyBodyParserRuleCall_2_0(), semanticObject.getBody())
        feeder.finish()

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Connection returns Connection
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         ((leftPorts+=VarRef leftPorts+=VarRef*) | (leftPorts+=VarRef leftPorts+=VarRef* iterated?='+'?)) 
    # 	 *         physical?='~&gt;'? 
    # 	 *         rightPorts+=VarRef 
    # 	 *         rightPorts+=VarRef* 
    # 	 *         delay=Expression? 
    # 	 *         serializer=Serializer?
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_Connection(self, context, semanticObject):
        """ generated source for method sequence_Connection """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Deadline returns Deadline
    # 	 *
    # 	 * Constraint:
    # 	 *     (delay=Expression code=Code)
    # 	 * </pre>
    # 	 
    def sequence_Deadline(self, context, semanticObject):
        """ generated source for method sequence_Deadline """
        if errorAcceptor != None:
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.DEADLINE__DELAY) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.DEADLINE__DELAY))
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.DEADLINE__CODE) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.DEADLINE__CODE))
        feeder = createSequencerFeeder(context, semanticObject)
        feeder.accept(self.grammarAccess.getDeadlineAccess().getDelayExpressionParserRuleCall_2_0(), semanticObject.getDelay())
        feeder.accept(self.grammarAccess.getDeadlineAccess().getCodeCodeParserRuleCall_4_0(), semanticObject.getCode())
        feeder.finish()

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Element returns Element
    # 	 *
    # 	 * Constraint:
    # 	 *     (keyvalue=KeyValuePairs | array=Array | literal=Literal | (time=INT unit=TimeUnit) | id=Path)
    # 	 * </pre>
    # 	 
    def sequence_Element(self, context, semanticObject):
        """ generated source for method sequence_Element """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Expression returns Literal
    # 	 *
    # 	 * Constraint:
    # 	 *     literal=Literal
    # 	 * </pre>
    # 	 
    def sequence_Expression(self, context, semanticObject):
        """ generated source for method sequence_Expression """
        if errorAcceptor != None:
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.LITERAL__LITERAL) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.LITERAL__LITERAL))
        feeder = createSequencerFeeder(context, semanticObject)
        feeder.accept(self.grammarAccess.getExpressionAccess().getLiteralLiteralParserRuleCall_0_1_0(), semanticObject.getLiteral())
        feeder.finish()

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     IPV4Host returns IPV4Host
    # 	 *     Host returns IPV4Host
    # 	 *
    # 	 * Constraint:
    # 	 *     (user=Kebab? addr=IPV4Addr port=INT?)
    # 	 * </pre>
    # 	 
    def sequence_IPV4Host(self, context, semanticObject):
        """ generated source for method sequence_IPV4Host """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     IPV6Host returns IPV6Host
    # 	 *     Host returns IPV6Host
    # 	 *
    # 	 * Constraint:
    # 	 *     (user=Kebab? addr=IPV6Addr port=INT?)
    # 	 * </pre>
    # 	 
    def sequence_IPV6Host(self, context, semanticObject):
        """ generated source for method sequence_IPV6Host """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Import returns Import
    # 	 *
    # 	 * Constraint:
    # 	 *     (reactorClasses+=ImportedReactor reactorClasses+=ImportedReactor* importURI=STRING)
    # 	 * </pre>
    # 	 
    def sequence_Import(self, context, semanticObject):
        """ generated source for method sequence_Import """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     ReactorDecl returns ImportedReactor
    # 	 *     ImportedReactor returns ImportedReactor
    # 	 *
    # 	 * Constraint:
    # 	 *     (reactorClass=[Reactor|ID] name=ID?)
    # 	 * </pre>
    # 	 
    def sequence_ImportedReactor(self, context, semanticObject):
        """ generated source for method sequence_ImportedReactor """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Input returns Input
    # 	 *     TypedVariable returns Input
    # 	 *     Variable returns Input
    # 	 *     Port returns Input
    # 	 *
    # 	 * Constraint:
    # 	 *     (attributes+=Attribute* mutable?='mutable'? widthSpec=WidthSpec? name=ID type=Type?)
    # 	 * </pre>
    # 	 
    def sequence_Input(self, context, semanticObject):
        """ generated source for method sequence_Input """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Instantiation returns Instantiation
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         name=ID 
    # 	 *         widthSpec=WidthSpec? 
    # 	 *         reactorClass=[ReactorDecl|ID] 
    # 	 *         (typeParms+=TypeParm typeParms+=TypeParm*)? 
    # 	 *         (parameters+=Assignment parameters+=Assignment*)? 
    # 	 *         host=Host?
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_Instantiation(self, context, semanticObject):
        """ generated source for method sequence_Instantiation """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     KeyValuePair returns KeyValuePair
    # 	 *
    # 	 * Constraint:
    # 	 *     (name=Kebab value=Element)
    # 	 * </pre>
    # 	 
    def sequence_KeyValuePair(self, context, semanticObject):
        """ generated source for method sequence_KeyValuePair """
        if errorAcceptor != None:
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.KEY_VALUE_PAIR__NAME) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.KEY_VALUE_PAIR__NAME))
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.KEY_VALUE_PAIR__VALUE) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.KEY_VALUE_PAIR__VALUE))
        feeder = createSequencerFeeder(context, semanticObject)
        feeder.accept(self.grammarAccess.getKeyValuePairAccess().getNameKebabParserRuleCall_0_0(), semanticObject.__name__)
        feeder.accept(self.grammarAccess.getKeyValuePairAccess().getValueElementParserRuleCall_2_0(), semanticObject.getValue())
        feeder.finish()

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     KeyValuePairs returns KeyValuePairs
    # 	 *
    # 	 * Constraint:
    # 	 *     (pairs+=KeyValuePair pairs+=KeyValuePair*)?
    # 	 * </pre>
    # 	 
    def sequence_KeyValuePairs(self, context, semanticObject):
        """ generated source for method sequence_KeyValuePairs """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     MethodArgument returns MethodArgument
    # 	 *
    # 	 * Constraint:
    # 	 *     (name=ID type=Type?)
    # 	 * </pre>
    # 	 
    def sequence_MethodArgument(self, context, semanticObject):
        """ generated source for method sequence_MethodArgument """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Method returns Method
    # 	 *
    # 	 * Constraint:
    # 	 *     (const?='const'? name=ID (arguments+=MethodArgument arguments+=MethodArgument*)? return=Type? code=Code)
    # 	 * </pre>
    # 	 
    def sequence_Method(self, context, semanticObject):
        """ generated source for method sequence_Method """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Mode returns Mode
    # 	 *     Variable returns Mode
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         initial?='initial'? 
    # 	 *         name=ID? 
    # 	 *         (
    # 	 *             stateVars+=StateVar | 
    # 	 *             timers+=Timer | 
    # 	 *             actions+=Action | 
    # 	 *             instantiations+=Instantiation | 
    # 	 *             connections+=Connection | 
    # 	 *             reactions+=Reaction
    # 	 *         )*
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_Mode(self, context, semanticObject):
        """ generated source for method sequence_Mode """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Model returns Model
    # 	 *
    # 	 * Constraint:
    # 	 *     (target=TargetDecl imports+=Import* preambles+=Preamble* reactors+=Reactor+)
    # 	 * </pre>
    # 	 
    def sequence_Model(self, context, semanticObject):
        """ generated source for method sequence_Model """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     NamedHost returns NamedHost
    # 	 *     Host returns NamedHost
    # 	 *
    # 	 * Constraint:
    # 	 *     (user=Kebab? addr=HostName port=INT?)
    # 	 * </pre>
    # 	 
    def sequence_NamedHost(self, context, semanticObject):
        """ generated source for method sequence_NamedHost """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Output returns Output
    # 	 *     TypedVariable returns Output
    # 	 *     Variable returns Output
    # 	 *     Port returns Output
    # 	 *
    # 	 * Constraint:
    # 	 *     (attributes+=Attribute* widthSpec=WidthSpec? name=ID type=Type?)
    # 	 * </pre>
    # 	 
    def sequence_Output(self, context, semanticObject):
        """ generated source for method sequence_Output """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Expression returns ParameterReference
    # 	 *     ParameterReference returns ParameterReference
    # 	 *
    # 	 * Constraint:
    # 	 *     parameter=[Parameter|ID]
    # 	 * </pre>
    # 	 
    def sequence_ParameterReference(self, context, semanticObject):
        """ generated source for method sequence_ParameterReference """
        if errorAcceptor != None:
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.PARAMETER_REFERENCE__PARAMETER) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.PARAMETER_REFERENCE__PARAMETER))
        feeder = createSequencerFeeder(context, semanticObject)
        feeder.accept(self.grammarAccess.getParameterReferenceAccess().getParameterParameterIDTerminalRuleCall_0_1(), semanticObject.eGet(LfPackage.Literals.PARAMETER_REFERENCE__PARAMETER, False))
        feeder.finish()

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Parameter returns Parameter
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         attributes+=Attribute* 
    # 	 *         name=ID 
    # 	 *         type=Type? 
    # 	 *         ((parens+='(' (init+=Expression init+=Expression*)? parens+=')') | (braces+='{' (init+=Expression init+=Expression*)? braces+='}'))?
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_Parameter(self, context, semanticObject):
        """ generated source for method sequence_Parameter """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Preamble returns Preamble
    # 	 *
    # 	 * Constraint:
    # 	 *     (visibility=Visibility? code=Code)
    # 	 * </pre>
    # 	 
    def sequence_Preamble(self, context, semanticObject):
        """ generated source for method sequence_Preamble """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Reaction returns Reaction
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         attributes+=Attribute* 
    # 	 *         mutation?='mutation'? 
    # 	 *         (triggers+=TriggerRef triggers+=TriggerRef*)? 
    # 	 *         (sources+=VarRef sources+=VarRef*)? 
    # 	 *         (effects+=VarRefOrModeTransition effects+=VarRefOrModeTransition*)? 
    # 	 *         code=Code 
    # 	 *         stp=STP? 
    # 	 *         deadline=Deadline?
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_Reaction(self, context, semanticObject):
        """ generated source for method sequence_Reaction """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     ReactorDecl returns Reactor
    # 	 *     Reactor returns Reactor
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         attributes+=Attribute* 
    # 	 *         federated?='federated'? 
    # 	 *         ((main?='main' | realtime?='realtime')? federated?='federated'?)* 
    # 	 *         name=ID? 
    # 	 *         (typeParms+=TypeParm typeParms+=TypeParm*)? 
    # 	 *         (parameters+=Parameter parameters+=Parameter*)? 
    # 	 *         host=Host? 
    # 	 *         (superClasses+=[ReactorDecl|ID] superClasses+=[ReactorDecl|ID]*)? 
    # 	 *         (
    # 	 *             preambles+=Preamble | 
    # 	 *             stateVars+=StateVar | 
    # 	 *             methods+=Method | 
    # 	 *             inputs+=Input | 
    # 	 *             outputs+=Output | 
    # 	 *             timers+=Timer | 
    # 	 *             actions+=Action | 
    # 	 *             instantiations+=Instantiation | 
    # 	 *             connections+=Connection | 
    # 	 *             reactions+=Reaction | 
    # 	 *             modes+=Mode
    # 	 *         )*
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_Reactor(self, context, semanticObject):
        """ generated source for method sequence_Reactor """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     STP returns STP
    # 	 *
    # 	 * Constraint:
    # 	 *     (value=Expression code=Code)
    # 	 * </pre>
    # 	 
    def sequence_STP(self, context, semanticObject):
        """ generated source for method sequence_STP """
        if errorAcceptor != None:
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.STP__VALUE) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.STP__VALUE))
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.STP__CODE) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.STP__CODE))
        feeder = createSequencerFeeder(context, semanticObject)
        feeder.accept(self.grammarAccess.getSTPAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue())
        feeder.accept(self.grammarAccess.getSTPAccess().getCodeCodeParserRuleCall_4_0(), semanticObject.getCode())
        feeder.finish()

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Serializer returns Serializer
    # 	 *
    # 	 * Constraint:
    # 	 *     type=STRING
    # 	 * </pre>
    # 	 
    def sequence_Serializer(self, context, semanticObject):
        """ generated source for method sequence_Serializer """
        if errorAcceptor != None:
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.SERIALIZER__TYPE) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.SERIALIZER__TYPE))
        feeder = createSequencerFeeder(context, semanticObject)
        feeder.accept(self.grammarAccess.getSerializerAccess().getTypeSTRINGTerminalRuleCall_1_0(), semanticObject.getType())
        feeder.finish()

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     StateVar returns StateVar
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         attributes+=Attribute* 
    # 	 *         reset?='reset'? 
    # 	 *         name=ID 
    # 	 *         type=Type? 
    # 	 *         ((parens+='(' (init+=Expression init+=Expression*)? parens+=')') | (braces+='{' (init+=Expression init+=Expression*)? braces+='}'))?
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_StateVar(self, context, semanticObject):
        """ generated source for method sequence_StateVar """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     TargetDecl returns TargetDecl
    # 	 *
    # 	 * Constraint:
    # 	 *     (name=ID config=KeyValuePairs?)
    # 	 * </pre>
    # 	 
    def sequence_TargetDecl(self, context, semanticObject):
        """ generated source for method sequence_TargetDecl """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Expression returns Time
    # 	 *     Time returns Time
    # 	 *
    # 	 * Constraint:
    # 	 *     (interval=INT unit=TimeUnit)
    # 	 * </pre>
    # 	 
    def sequence_Time(self, context, semanticObject):
        """ generated source for method sequence_Time """
        if errorAcceptor != None:
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.TIME__INTERVAL) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.TIME__INTERVAL))
            if transientValues.isValueTransient(semanticObject, LfPackage.Literals.TIME__UNIT) == ValueTransient.YES:
                errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LfPackage.Literals.TIME__UNIT))
        feeder = createSequencerFeeder(context, semanticObject)
        feeder.accept(self.grammarAccess.getTimeAccess().getIntervalINTTerminalRuleCall_0_0(), semanticObject.getInterval())
        feeder.accept(self.grammarAccess.getTimeAccess().getUnitTimeUnitParserRuleCall_1_0(), semanticObject.getUnit())
        feeder.finish()

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Timer returns Timer
    # 	 *     Variable returns Timer
    # 	 *
    # 	 * Constraint:
    # 	 *     (attributes+=Attribute* name=ID (offset=Expression period=Expression?)?)
    # 	 * </pre>
    # 	 
    def sequence_Timer(self, context, semanticObject):
        """ generated source for method sequence_Timer """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     TypeParm returns TypeParm
    # 	 *
    # 	 * Constraint:
    # 	 *     (literal=TypeExpr | code=Code)
    # 	 * </pre>
    # 	 
    def sequence_TypeParm(self, context, semanticObject):
        """ generated source for method sequence_TypeParm """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     Type returns Type
    # 	 *
    # 	 * Constraint:
    # 	 *     ((time?='time' arraySpec=ArraySpec?) | (id=DottedName (typeParms+=Type typeParms+=Type*)? stars+='*'* arraySpec=ArraySpec?) | code=Code)
    # 	 * </pre>
    # 	 
    def sequence_Type(self, context, semanticObject):
        """ generated source for method sequence_Type """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     TriggerRef returns VarRef
    # 	 *     VarRef returns VarRef
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         variable=[Variable|ID] | 
    # 	 *         (container=[Instantiation|ID] variable=[Variable|ID]) | 
    # 	 *         (interleaved?='interleaved' (variable=[Variable|ID] | (container=[Instantiation|ID] variable=[Variable|ID])))
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_VarRef(self, context, semanticObject):
        """ generated source for method sequence_VarRef """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     VarRefOrModeTransition returns VarRef
    # 	 *
    # 	 * Constraint:
    # 	 *     (
    # 	 *         variable=[Variable|ID] | 
    # 	 *         (container=[Instantiation|ID] variable=[Variable|ID]) | 
    # 	 *         (interleaved?='interleaved' (variable=[Variable|ID] | (container=[Instantiation|ID] variable=[Variable|ID]))) | 
    # 	 *         (transition=ModeTransition variable=[Mode|ID])
    # 	 *     )
    # 	 * </pre>
    # 	 
    def sequence_VarRef_VarRefOrModeTransition(self, context, semanticObject):
        """ generated source for method sequence_VarRef_VarRefOrModeTransition """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     WidthSpec returns WidthSpec
    # 	 *
    # 	 * Constraint:
    # 	 *     (ofVariableLength?=']' | (terms+=WidthTerm terms+=WidthTerm*))
    # 	 * </pre>
    # 	 
    def sequence_WidthSpec(self, context, semanticObject):
        """ generated source for method sequence_WidthSpec """
        genericSequencer.createSequence(context, semanticObject)

    # 	 * <pre>
    # 	 * Contexts:
    # 	 *     WidthTerm returns WidthTerm
    # 	 *
    # 	 * Constraint:
    # 	 *     (width=INT | parameter=[Parameter|ID] | port=VarRef | code=Code)
    # 	 * </pre>
    # 	 
    def sequence_WidthTerm(self, context, semanticObject):
        """ generated source for method sequence_WidthTerm """
        genericSequencer.createSequence(context, semanticObject)
