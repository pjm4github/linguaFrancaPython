#!/usr/bin/env python
""" generated source for module LFParsingTest """
# 
#  * generated by Xtext 2.23.0
#  
# package: org.lflang.tests
# import java.util.List
# import org.eclipse.emf.ecore.resource.Resource.Diagnostic
# import org.eclipse.xtext.testing.InjectWith
# import org.eclipse.xtext.testing.extensions.InjectionExtension
# import org.eclipse.xtext.testing.util.ParseHelper
# import org.eclipse.xtext.xbase.lib.IterableExtensions

import org.junit.jupiter.api.Assertions

import org.junit.jupiter.api.Test

import org.junit.jupiter.api.extension.ExtendWith

from org.lflang.lf import Model
# import com.google.inject.Inject

@ExtendWith(InjectionExtension.__class__)
@InjectWith(LFInjectorProvider.__class__)
class LFParsingTest(object):
    """ generated source for class LFParsingTest """
    parseHelper = None

    def testLexingEmptyTargetProperties(self):
        """ generated source for method testLexingEmptyTargetProperties """
        assertNoParsingErrorsIn("target C { };      \nreactor Foo {}")
        assertNoParsingErrorsIn("target C {a:b,};   \nreactor Foo {}")
        expectParsingErrorIn("target C {,};      \nreactor Foo {}")
        #  array elements
        #  assertNoParsingErrorsIn("target C {x:[ ]};  \nreactor Foo {}");
        #  assertNoParsingErrorsIn("target C {x:[]};   \nreactor Foo {}");
        #  assertNoParsingErrorsIn("target C {x:[,]};  \nreactor Foo {}");

    def testLexingLifetimeAnnots(self):
        """ generated source for method testLexingLifetimeAnnots """
        assertNoParsingErrorsIn(makeLfTargetCode("Rust", "        struct Hello<'a> { \n" + "            r: &'a str,\n" + "            r2: &'a Box<Hello<'a>>,\n" + "        }"))

    def testLexingSingleLifetimeAnnot(self):
        """ generated source for method testLexingSingleLifetimeAnnot """
        #  just to be sure, have a single lifetime annot.
        assertNoParsingErrorsIn(makeLfTargetCode("Rust", "        struct Hello { \n" + "            r: &'static str,\n" + "        }"))

    def testLexingNewlineCont(self):
        """ generated source for method testLexingNewlineCont """
            #         This example looks like this:
        #         "a\
        #         bcde"
        #         This is valid C++ to escape a newline.
        #          
        assertNoParsingErrorsIn(makeLfTargetCode("Cpp", "        \"a\\\n" + "        bcde\"\n"))

    def testLexingSquotedString(self):
        """ generated source for method testLexingSquotedString """
        #  we can't do that anymore
        expectParsingErrorIn(makeLfTargetCode("Python", "a = ' a string '"))

    def testLexingDquotedString(self):
        """ generated source for method testLexingDquotedString """
        assertNoParsingErrorsIn(makeLfTargetCode("Python", "a = \" a string \""))

    def testLexingMultilineString(self):
        """ generated source for method testLexingMultilineString """
        assertNoParsingErrorsIn(makeLfTargetCode("Python", "a = \"\"\" a 'string' \"\"\""))
        assertNoParsingErrorsIn(makeLfTargetCode("Python", "a = \"\"\" a 'strin\ng' \"\"\""))
        assertNoParsingErrorsIn(makeLfTargetCode("Python", "a = \"\"\" \na 'string'\n \"\"\""))

    def testLexingDquotedStringWithEscape(self):
        """ generated source for method testLexingDquotedStringWithEscape """
        assertNoParsingErrorsIn(makeLfTargetCode("C", "printf(\"Hello World.\\n\");\n"))

    def testLexingCharLiteral(self):
        """ generated source for method testLexingCharLiteral """
        assertNoParsingErrorsIn(makeLfTargetCode("C", "char c0 = 'c';"))

    def testLexingEscapedCharLiteral(self):
        """ generated source for method testLexingEscapedCharLiteral """
        assertNoParsingErrorsIn(makeLfTargetCode("C", "char c0 = '\\n';"))

    def makeLfTargetCode(self, target, code_):
        """ generated source for method makeLfTargetCode """
        return "target " + target + ";\n" + "reactor Foo {\n" + "    preamble {=\n" + "       " + code_ + "\n" + "    =}\n" + "}"

    def assertNoParsingErrorsIn(self, source):
        """ generated source for method assertNoParsingErrorsIn """
        errors = doParse(source)
        Assertions.assertTrue(errors.isEmpty(), "Unexpected errors: " + IterableExtensions.join(errors, ", "))

    def expectParsingErrorIn(self, source):
        """ generated source for method expectParsingErrorIn """
        errors = doParse(source)
        Assertions.assertFalse(errors.isEmpty(), "Expected a parsing error, none occurred")

    def doParse(self, source):
        """ generated source for method doParse """
        result = self.parseHelper.parse(source)
        Assertions.assertNotNull(result)
        return result.eResource().getErrors()
